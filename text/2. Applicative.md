# Part two. Currying, Apply, Applicative, HKT

https://dev.to/gcanti/series/680 - the fp-ts author articles cycle.

This is extremely short conspect.

In the first part gcanty talked about composition. The whole program is composition of functions. There are three cases:

| Function f    | Function g    | Composition  |Comment|
|:-------------:|:-------------:|:-----:| ---:|
| pure | pure | g(f()) | usual function calls |
| has side effects| pure and receives one argument | lift(g)(f()) | using Functor |
| has side effects | pure and receives more than one argument | ? | using Applicative |


## 1. Currying
> Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument. For example, a function that takes two arguments, one from B and one from C, and produces outputs in D, by currying is translated into a function that takes a single argument from C and produces as outputs functions from B to C.
> (c) Wiki

https://javascript.info/currying-partials:
``` javascript
function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  };
  
// usage examples
function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

alert( curriedSum(1, 2, 3) ); // 6, still callable normally
alert( curriedSum(1)(2,3) ); // 6, currying of 1st arg
alert( curriedSum(1)(2)(3) ); // 6, full currying
```

## 2. Apply and Applicative

Applicative solves the problem that appear in third row in the table. We want to compose two functions, first one has side effects and second receives more than one argument.

Let's show some example:

``` typescript
// f is 'effectful' (with side effects) function
const f = async (a: string): Option<number> => isNan(a) ? none : some(Number(a);
// g is pure function that receives several inputs
const g = (b: number, c: string, d: boolean): string => d ? `${b}: ${c}` : `${c}: ${b}`;
// The problem: we want to call g(f()). How to do this?
```

To compose function f and g, we need to turn g into one-argument function and then use Functor.

To achieve that function g should be *curried*. And Apply is a Functor with a function that does this curring.

gcanty calls this function ap and the type is Apply:

```typescript
interface Apply<F> extends Functor<F> {
  ap: <C, D>(fcd: HKT<F, (c: C) => D>, fc: HKT<F, C>) => HKT<F, D>
}
```

There are scary things written in the article, which say that unpack and ap can be derrived from each other.
```
unpack: <C, D>(fcd: HKT<F, (c: C) => D>) => ((fc: HKT<F, C>) => HKT<F, D>)
ap:     <C, D>(fcd: HKT<F, (c: C) => D>, fc: HKT<F, C>) => HKT<F, D>
```
HKT means "type that is constructed from the given one".

